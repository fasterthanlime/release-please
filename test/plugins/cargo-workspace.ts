// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import CargoWorkspaceDependencyUpdates from '../../src/plugins/cargo-workspace';
import {describe, it, afterEach} from 'mocha';
import {expect} from 'chai';
import * as sinon from 'sinon';
import {GitHub} from '../../src/github';
import {Config} from '../../src/manifest';
import {buildGitHubFileRaw} from '../releasers/utils';
import {ManifestPackageWithPRData} from '../../src';
import {CheckpointType} from '../../src/util/checkpoint';
import {stringifyExpectedChanges} from '../helpers';
import snapshot = require('snap-shot-it');

const sandbox = sinon.createSandbox();

function stringifyActual(actual: ManifestPackageWithPRData[]) {
  let stringified = '';
  for (const pkgsWithPRData of actual) {
    const changes = pkgsWithPRData.prData.changes;
    stringified +=
      '='.repeat(20) +
      '\n' +
      JSON.stringify(
        pkgsWithPRData,
        (k, v) => (k === ' changes' ? undefined : v),
        2
      ) +
      '\n';
    stringified += stringifyExpectedChanges([...changes]) + '\n';
  }
  return stringified;
}

const pkgAData: ManifestPackageWithPRData = {
  config: {
    releaseType: 'rust',
    packageName: 'pkgA',
    path: 'packages/pkgA',
  },
  prData: {
    version: '1.1.2',
    changes: new Map([
      [
        'packages/pkgA/Cargo.toml',
        {
          content: `
        [package]
        name = "pkgA"
        version = "1.1.2"
        `,
          mode: '100644',
        },
      ],
    ]),
  },
};

describe('CargoWorkspaceDependencyUpdates', () => {
  afterEach(() => {
    sandbox.restore();
  });

  function mockGithub(github: GitHub) {
    return sandbox.mock(github);
  }

  function expectGetFiles(
    mock: sinon.SinonMock,
    namesContents: [string, string | number | false][]
  ) {
    for (const [file, contents] of namesContents) {
      if (typeof contents === 'string') {
        mock
          .expects('getFileContentsOnBranch')
          .withExactArgs(file, 'main')
          .once()
          .resolves(buildGitHubFileRaw(contents));
      } else if (contents) {
        mock
          .expects('getFileContentsOnBranch')
          .withExactArgs(file, 'main')
          .once()
          .rejects(
            Object.assign(Error(`error: ${contents}`), {status: contents})
          );
      } else {
        mock
          .expects('getFileContentsOnBranch')
          .withExactArgs(file, 'main')
          .never();
      }
    }
  }

  describe('run', () => {
    it('handles a simple chain where root pkg update cascades to dependents', async function () {
      const config: Config = {
        packages: {}, // unused, required by interface
        parsedPackages: [
          {path: 'packages/pkgA', releaseType: 'rust'},
          {path: 'packages/pkgB', releaseType: 'rust'},
          {path: 'packages/pkgC', releaseType: 'rust'},
          // should ignore non-rust packages
          {path: 'py/pkg', releaseType: 'python'},
        ],
      };
      const github = new GitHub({
        owner: 'fake',
        repo: 'repo',
        defaultBranch: 'main',
      });
      const mock = mockGithub(github);

      // packages B and C did not get release-please updates but B depends on A
      // and C depends on B so both should be getting patch bumps
      expectGetFiles(mock, [
        [
          'Cargo.toml',
          `
          [workspace]
          members = ["packages/pkgA", "packages/pkgB", "packages/pkgC"]
        `,
        ],
        ['packages/pkgA/Cargo.toml', false],
        [
          'packages/pkgB/Cargo.toml',
          `
        [package]
        name = "pkgB"
        version = "2.2.2"

        [dependencies]
        pkgA = { version = "1.1.1", path = "../pkgA" }
        `,
        ],
        [
          'packages/pkgC/Cargo.toml',
          `
        [package]
        name = "pkgC"
        version = "3.3.3"

        [dependencies]
        pkgB = { version = "2.2.2", path = "../pkgB" }
        `,
        ],
        [
          'Cargo.lock',
          `
          # This file is automatically @generated by Cargo.
          # It is not intended for manual editing.
          [[package]]
          name = "pkgA"
          version = "1.1.1"
          dependencies = []

          [[package]]
          name = "pkgB"
          version = "2.2.2"
          dependencies = ["pkgA"]

          [[package]]
          name = "pkgC"
          version = "3.3.3"
          dependencies = ["pkgB"]
          `,
        ],
      ]);

      // pkgA had a patch bump from manifest.runReleasers()
      const newManifestVersions = new Map([
        ['packages/pkgA', '1.1.2'],
        ['py/pkg', '1.1.2'],
      ]);
      // all incoming non-Rust changes should be left alone and returned
      const pyPkgData: ManifestPackageWithPRData = {
        config: {
          releaseType: 'python',
          path: 'py/pkg',
        },
        prData: {
          version: '1.1.2',
          changes: new Map([
            [
              'py/pkg/setup.py',
              {
                content: 'some python version content',
                mode: '100644',
              },
            ],
          ]),
        },
      };
      const pkgsWithPRData: ManifestPackageWithPRData[] = [
        pkgAData,
        pyPkgData, // should ignore non-rust packages,
      ];

      const logs: [string, CheckpointType][] = [];
      const checkpoint = (msg: string, type: CheckpointType) =>
        logs.push([msg, type]);
      const cargoWS = new CargoWorkspaceDependencyUpdates(
        github,
        config,
        'cargo-workspace',
        checkpoint
      );
      const [actualManifest, actualChanges] = await cargoWS.run(
        newManifestVersions,
        pkgsWithPRData
      );
      mock.verify();
      expect([...actualManifest]).to.eql([
        ['packages/pkgA', '1.1.2'],
        ['py/pkg', '1.1.2'],
        ['packages/pkgB', '2.2.3'],
        ['packages/pkgC', '3.3.4'],
      ]);
      const snapPrefix = this.test!.fullTitle();
      snapshot(snapPrefix + ' logs', logs);
      snapshot(snapPrefix + ' changes', stringifyActual(actualChanges));
    });
  });
});
